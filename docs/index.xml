<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on </title>
    <link>https://d2a4u.github.io/meteor/docs/</link>
    <description>Recent content in Docs on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Mon, 25 Jan 2021 23:25:00 +0000</lastBuildDate><atom:link href="https://d2a4u.github.io/meteor/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Get Started</title>
      <link>https://d2a4u.github.io/meteor/docs/introduction/getstarted/</link>
      <pubDate>Mon, 25 Jan 2021 23:54:06 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/introduction/getstarted/</guid>
      <description>meteor is a wrapper around Java AWS SDK v2 library, provides higher level API over standard DynamoDB&amp;rsquo;s actions.
Features  wraps AWS Java SDK V2 CRUD actions stream batch actions or scan table as fs2 Stream auto processes left over items auto remove duplication in batch actions support DynamoDB&amp;rsquo;s single table design provides codec as a simple abstraction and syntax on top of AttributeValue support multiple codec libraries including Dynosaur and Scanamo  Installation Add the following to your build.</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://d2a4u.github.io/meteor/docs/introduction/helloworld/</link>
      <pubDate>Tue, 26 Jan 2021 22:25:49 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/introduction/helloworld/</guid>
      <description>Quick complete example to write and read from a DynamoDB table.
Define Codec Type Classes Codec (Encoder and Decoder) type classes are required to write and read a value of type T to and from Java&amp;rsquo;s AttributeValue.
import meteor._ import meteor.codec._ import meteor.syntax._ case class Book(id: Int, content: String) object Book { implicit val bookEncoder: Encoder[Book] = Encoder.instance { book =&amp;gt; Map( &amp;#34;id&amp;#34; -&amp;gt; book.id.asAttributeValue, &amp;#34;content&amp;#34; -&amp;gt; book.content.asAttributeValue ).asAttributeValue } implicit val bookDecoder: Decoder[Book] = Decoder.</description>
    </item>
    
    <item>
      <title>Build and Tests</title>
      <link>https://d2a4u.github.io/meteor/docs/introduction/runtests/</link>
      <pubDate>Wed, 27 Jan 2021 00:39:02 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/introduction/runtests/</guid>
      <description>Build The project requires Scala 2.12.12 or 2.13.3. To build the project locally:
git@github.com:d2a4u/meteor.git cd ./meteor sbt compile Tests Local Unit tests can be run locally by sbt test. Integration tests run against docker container of DynamoDB Local. Hence, you will need docker installed and then to run integration tests:
docker-compose up -d # make sure that the service is ready before running tests sbt it:test A docker-compose.yml is provided at the root of the project.</description>
    </item>
    
    <item>
      <title>Expression</title>
      <link>https://d2a4u.github.io/meteor/docs/api/expression/</link>
      <pubDate>Thu, 28 Jan 2021 10:14:17 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/api/expression/</guid>
      <description>An Expression case class represents various expressions in DynamoDB actions including:
 FilterExpression - Scan API UpdateExpression - UpdateItem API ConditionExpression - UpdateItem API ConditionExpression - PutItem API ProjectionExpression - GetItem, Query, or Scan API  These expressions in DynamoDB share the same structure, hence, in meteor they are abstracted as:
case class Expression( expression: String, attributeNames: Map[String, String], attributeValues: Map[String, AttributeValue] ) For example:
Expression( expression = &amp;#34;#pAt BETWEEN :from AND :to&amp;#34;, attributeNames = Map( &amp;#34;#pAt&amp;#34; -&amp;gt; &amp;#34;publishedAt&amp;#34; ), attributeValues = Map( &amp;#34;:from&amp;#34; -&amp;gt; 1870.</description>
    </item>
    
    <item>
      <title>High Level API</title>
      <link>https://d2a4u.github.io/meteor/docs/api/highlevel/</link>
      <pubDate>Sat, 06 Mar 2021 07:43:39 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/api/highlevel/</guid>
      <description>The actions API is considered low level because it is a 1-2-1 mapping to the Java AWS SDK calls. In contrast, high level API abstracts over DynamoDB tables which makes it simpler to work with. For example:
Low level API action:
import meteor._ import cats.effect.IO val client: Client[IO] = ??? val booksTable = PartitionKeyTable[Int](&amp;#34;books-table&amp;#34;, KeyDef[Int](&amp;#34;id&amp;#34;, DynamoDbType.N)) val lotr = Book(1, &amp;#34;The Lord of the Rings&amp;#34;) val get = client.get[Int, Book]( booksTable, 1, consistentRead = false ) High level API table:</description>
    </item>
    
    <item>
      <title>Item Actions</title>
      <link>https://d2a4u.github.io/meteor/docs/api/itemactions/</link>
      <pubDate>Wed, 27 Jan 2021 00:17:27 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/api/itemactions/</guid>
      <description>Most actions have several overloading methods for a table with composite keys, or a simple table with only partition key.
Get Most simple action to get an item from a table by key(s). Since return type U is only on the return type, all type parameters are required to be passed in explicitly.
def get[P: Encoder, S: Encoder, U: Decoder]( table: CompositeKeysTable[P, S], partitionKey: P, sortKey: S, consistentRead: Boolean ): F[Option[U]] Retrieve Similar to Get but can return multiple items by:</description>
    </item>
    
    <item>
      <title>Batch Actions</title>
      <link>https://d2a4u.github.io/meteor/docs/api/batchactions/</link>
      <pubDate>Wed, 27 Jan 2021 00:17:46 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/api/batchactions/</guid>
      <description>All batch APIs require a Java BackoffStrategy. A default value is provided by:
import meteor.Client Client.BackoffStrategy.default The settings for this default is based on AWS SDK&amp;rsquo;s default for DynamoDbRetryPolicy.
De-duplication DynamoDB batch write action has validation on performing multiple operations on the same item, such as, create and delete the same item in the same batch request. meteor provides de-duplication internally such that, within a batch, the later action is chosen over all previous actions on the same item.</description>
    </item>
    
    <item>
      <title>Table Actions</title>
      <link>https://d2a4u.github.io/meteor/docs/api/tableactions/</link>
      <pubDate>Wed, 27 Jan 2021 00:17:07 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/api/tableactions/</guid>
      <description>Create Table creation returns F[Unit] where F[_] is semantically blocked (no actual JVM thread being blocked) until the table has been created and its status is available.
import meteor._ val creation: F[Unit] = client.createPartitionKeyTable( &amp;#34;books-table&amp;#34;, KeyDef[Int](&amp;#34;id&amp;#34;, DynamoDbType.N), BillingMode.PAY_PER_REQUEST ) attributeDefinition is required only when there are secondary indexes on those attributes. For example, given the following secondary index:
import software.amazon.awssdk.services.dynamodb.model._ val global2ndIndex = GlobalSecondaryIndex .builder() .indexName(&amp;#34;books-by-author&amp;#34;) .keySchema( KeySchemaElement.builder().attributeName(&amp;#34;author&amp;#34;).keyType(KeyType.HASH).build(), KeySchemaElement.builder().attributeName(&amp;#34;title&amp;#34;).keyType(KeyType.RANGE).build() ) .</description>
    </item>
    
    <item>
      <title>meteor Codec</title>
      <link>https://d2a4u.github.io/meteor/docs/codec/meteor/</link>
      <pubDate>Tue, 26 Jan 2021 22:18:50 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/codec/meteor/</guid>
      <description>meteor provides Encoder and Decoder type classes to convert any A to and from Java&amp;rsquo;s Attributevalue. Their signatures are followed:
trait Encoder[A] { def write(a: A): AttributeValue } trait Decoder[A] { def read(av: AttributeValue): Either[DecoderError, A] } Please note that the write side is always success, such that, given an A, we can always write it to an AttributeValue. However, reading an AttributeValue into A might fail as we don&amp;rsquo;t know the schema of an AttributeValue.</description>
    </item>
    
    <item>
      <title>Dynosaur Schema</title>
      <link>https://d2a4u.github.io/meteor/docs/codec/dynosaur/</link>
      <pubDate>Tue, 26 Jan 2021 22:19:06 +0000</pubDate>
      
      <guid>https://d2a4u.github.io/meteor/docs/codec/dynosaur/</guid>
      <description>The meteor-dynosaur module provides integration with Dynosaur library. It provides implicit construction from Dynosaur&amp;rsquo;s schema to meteor&amp;rsquo;s codec. This is an experiment feature, hence, it is subjected to change.
import meteor.dynosaur.formats.conversions._ import meteor.codec.Codec implicit val bookSchema: Schema[Book] = ... val bookCodec: Codec[Book] = implicitly[Codec[Book]] </description>
    </item>
    
  </channel>
</rss>
